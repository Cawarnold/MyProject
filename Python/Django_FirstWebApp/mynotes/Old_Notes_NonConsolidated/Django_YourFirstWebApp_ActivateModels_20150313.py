## Django_YourFirstWebApp_ActivateModels_20150313

# Writing your first Django app, part 1
## 	https://docs.djangoproject.com/en/1.7/intro/tutorial01/

# Directory
# C:\Users\Christian\Documents\GitHub\MyProject\Python\Django_FirstWebApp



########################################################################################################################
########################################################################################################################
########################################################################################################################


#### Activating models ####

# That small bit of model code gives Django a lot of information. With it, Django is able to:

# Create a database schema (CREATE TABLE statements) for this app.
# Create a Python database-access API for accessing Question and Choice objects.
# But first we need to tell our project that the polls app is installed.

# Philosophy
# Django apps are “pluggable”: You can use an app in multiple projects, and you can distribute apps, 
# because they don’t have to be tied to a given Django installation.

# Edit the mysite/settings.py file again, 
# and change the INSTALLED_APPS setting to include the string 'polls'. So it’ll look like this:

INSTALLED_APPS = (
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'polls',
)

# Now Django knows to include the polls app. Let’s run another command:

	#> $ python manage.py makemigrations polls

# You should see something similar to the following:

Migrations for 'polls':
  0001_initial.py:
    - Create model Question
    - Create model Choice
    - Add field question to choice

# By running makemigrations, you’re telling Django that you’ve made some changes to your models 
# (in this case, you’ve made new ones) and that you’d like the changes to be stored as a migration.

# Migrations are how Django stores changes to your models (and thus your database schema) - 
# they’re just files on disk. 
# You can read the migration for your new model if you like; 
# it’s the file polls/migrations/0001_initial.py. 
# Don’t worry, you’re not expected to read them every time Django makes one, 
# but they’re designed to be human-editable in case you want to manually tweak how Django changes things.

# There’s a command that will run the migrations for you and manage your database schema automatically - 
# that’s called migrate, and we’ll come to it in a moment - 
# but first, let’s see what SQL that migration would run. 
# The sqlmigrate command takes migration names and returns their SQL:

	#> $ python manage.py sqlmigrate polls 0001

# You should see something similar to the following (we’ve reformatted it for readability):

BEGIN;
CREATE TABLE "polls_choice" (
    "id" serial NOT NULL PRIMARY KEY,
    "choice_text" varchar(200) NOT NULL,
    "votes" integer NOT NULL
);
CREATE TABLE "polls_question" (
    "id" serial NOT NULL PRIMARY KEY,
    "question_text" varchar(200) NOT NULL,
    "pub_date" timestamp with time zone NOT NULL
);
ALTER TABLE "polls_choice" ADD COLUMN "question_id" integer NOT NULL;
ALTER TABLE "polls_choice" ALTER COLUMN "question_id" DROP DEFAULT;
CREATE INDEX "polls_choice_7aa0f6ee" ON "polls_choice" ("question_id");
ALTER TABLE "polls_choice"
  ADD CONSTRAINT "polls_choice_question_id_246c99a640fbbd72_fk_polls_question_id"
    FOREIGN KEY ("question_id")
    REFERENCES "polls_question" ("id")
    DEFERRABLE INITIALLY DEFERRED;

COMMIT;


# Note the following:

# The exact output will vary depending on the database you are using. The example above is generated for PostgreSQL.
# Table names are automatically generated by combining the name of the app (polls) 
# and the lowercase name of the model – question and choice. (You can override this behavior.)
# Primary keys (IDs) are added automatically. (You can override this, too.)
# By convention, Django appends "_id" to the foreign key field name. (Yes, you can override this, as well.)
# The foreign key relationship is made explicit by a FOREIGN KEY constraint. 
# Don’t worry about the DEFERRABLE parts; 
# that’s just telling PostgreSQL to not enforce the foreign key until the end of the transaction.

# It’s tailored to the database you’re using, so database-specific field types such as 
# auto_increment (MySQL), serial (PostgreSQL), or integer primary key autoincrement (SQLite) 
# are handled for you automatically. Same goes for quoting of field names – e.g., using double quotes or single quotes.

# The sqlmigrate command doesn’t actually run the migration on your database - 
# it just prints it to the screen so that you can see what SQL Django thinks is required. 
# It’s useful for checking what Django is going to do or if you have database administrators who require SQL scripts for changes.

# If you’re interested, you can also run 

	#> $ python manage.py check

System check identifier no issues (0 silences).

#; this checks for any problems in your project without making migrations or touching the database.

# Now, run migrate again to create those model tables in your database:

	#> $ python manage.py migrate

Operations to perform:
  Apply all migrations: admin, contenttypes, polls, auth, sessions
Running migrations:
  Applying <migration name>... OK


# The migrate command takes all the migrations that haven’t been applied 
# (Django tracks which ones are applied using a special table in your database called django_migrations) 
# and runs them against your database - 
# essentially, synchronizing the changes you made to your models with the schema in the database.

# Migrations are very powerful and let you change your models over time, as you develop your project, 
# without the need to delete your database or tables and make new ones - 
# it specializes in upgrading your database live, without losing data. 
# We’ll cover them in more depth in a later part of the tutorial, but for now, 
# remember the three-step guide to making model changes:

	# Change your models (in models.py).
	# Run python manage.py makemigrations to create migrations for those changes
	# Run python manage.py migrate to apply those changes to the database.
	# The reason there’s separate commands to make and apply migrations is because 
	# you’ll commit migrations to your version control system and ship them with your app; 
	# they not only make your development easier, they’re also useable by other developers and in production.

# Read the django-admin.py documentation for full information on what the manage.py utility can do.
